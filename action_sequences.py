"""
Action Sequence Builder - Construtor de Sequ√™ncias de A√ß√µes

Este m√≥dulo cont√©m TODA a l√≥gica de neg√≥cio de opera√ß√µes de ba√∫.
O servidor usa este m√≥dulo para construir sequ√™ncias completas de a√ß√µes at√¥micas
que s√£o enviadas ao cliente para execu√ß√£o cega.

ARQUITETURA:
- Servidor TEM toda a l√≥gica (quando, como, onde)
- Cliente APENAS executa sequ√™ncias JSON (burro)

Opera√ß√µes suportadas:
- Feeding (alimenta√ß√£o)
- Cleaning (limpeza de invent√°rio)
- Maintenance (manuten√ß√£o de varas)
- Rod Switch (troca de vara)
"""

import logging
from typing import List, Dict, Optional, Tuple

logger = logging.getLogger(__name__)


class ActionSequenceBuilder:
    """
    Construtor de sequ√™ncias de a√ß√µes para opera√ß√µes de ba√∫

    TODA a l√≥gica de neg√≥cio est√° aqui!
    Cliente n√£o sabe o que est√° fazendo, apenas executa a√ß√µes at√¥micas.
    """

    def __init__(self, user_config: dict):
        """
        Inicializar builder com configura√ß√µes do usu√°rio

        Args:
            user_config: Configura√ß√µes sincronizadas do cliente
                - chest_side: "left" ou "right"
                - chest_distance: pixels de movimento de c√¢mera
                - chest_vertical_offset: offset vertical
                - slot_positions: {1: (x, y), 2: (x, y), ...}
                - inventory_area: [x1, y1, x2, y2]
                - chest_area: [x1, y1, x2, y2]
                - feeds_per_session: quantas comidas por alimenta√ß√£o
                - bait_priority: ordem de prioridade de iscas
        """
        self.config = user_config
        logger.info(f"üèóÔ∏è ActionSequenceBuilder inicializado")

    # ========== M√âTODOS P√öBLICOS (OPERA√á√ïES COMPLETAS) ==========

    def build_feeding_sequence(
        self,
        food_location: Dict[str, int],
        eat_location: Dict[str, int]
    ) -> List[Dict]:
        """
        Construir sequ√™ncia completa de alimenta√ß√£o

        Sequ√™ncia:
        1. Parar fishing cycle
        2. Abrir ba√∫
        3. Clicar na comida
        4. Clicar no bot√£o "eat" N vezes
        5. Fechar ba√∫

        Args:
            food_location: {"x": 1306, "y": 858} (detectado no cliente)
            eat_location: {"x": 1083, "y": 373} (detectado no cliente)

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.info(f"üçñ Construindo sequ√™ncia de feeding")
        logger.info(f"   Food: ({food_location['x']}, {food_location['y']})")
        logger.info(f"   Eat: ({eat_location['x']}, {eat_location['y']})")

        actions = []

        # Passo 1: Parar fishing cycle
        actions.extend(self._build_stop_fishing())

        # Passo 2: Abrir ba√∫
        actions.extend(self._build_chest_open())

        # Passo 3: Aguardar ba√∫ abrir completamente
        actions.append({
            "type": "wait",
            "duration": 1.5,
            "comment": "Aguardar ba√∫ abrir"
        })

        # Passo 4: Clicar na comida
        actions.append({
            "type": "click",
            "x": food_location["x"],
            "y": food_location["y"],
            "comment": "Pegar comida do ba√∫"
        })
        actions.append({"type": "wait", "duration": 1.0})

        # Passo 5: Clicar no bot√£o "eat" N vezes
        feeds_per_session = self.config.get("feeds_per_session", 2)
        logger.info(f"   Feeds per session: {feeds_per_session}")

        for i in range(feeds_per_session):
            actions.append({
                "type": "click",
                "x": eat_location["x"],
                "y": eat_location["y"],
                "comment": f"Comer {i+1}/{feeds_per_session}"
            })
            actions.append({"type": "wait", "duration": 1.5})

        # Passo 6: Fechar ba√∫
        actions.extend(self._build_chest_close())

        logger.info(f"‚úÖ Sequ√™ncia de feeding constru√≠da: {len(actions)} a√ß√µes")
        return actions

    def build_cleaning_sequence(
        self,
        fish_locations: List[Dict[str, int]]
    ) -> List[Dict]:
        """
        Construir sequ√™ncia completa de limpeza de invent√°rio

        Sequ√™ncia:
        1. Parar fishing cycle
        2. Abrir ba√∫
        3. Para cada peixe:
           - Clicar direito (transfere para ba√∫)
        4. Fechar ba√∫

        Args:
            fish_locations: [{"x": 709, "y": 700}, ...] (detectados no cliente)

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.info(f"üßπ Construindo sequ√™ncia de cleaning")
        logger.info(f"   Peixes detectados: {len(fish_locations)}")

        actions = []

        # Passo 1: Parar fishing cycle
        actions.extend(self._build_stop_fishing())

        # Passo 2: Abrir ba√∫
        actions.extend(self._build_chest_open())

        # Passo 3: Aguardar ba√∫ abrir completamente (mais tempo para itens carregarem)
        actions.append({
            "type": "wait",
            "duration": 2.5,
            "comment": "Aguardar ba√∫ abrir e itens carregarem"
        })

        # Passo 4: Transferir cada peixe (m√°ximo 30 itens)
        max_items = min(len(fish_locations), 30)
        logger.info(f"   Transferindo {max_items} itens")

        for i, loc in enumerate(fish_locations[:max_items]):
            actions.append({
                "type": "click_right",
                "x": loc["x"],
                "y": loc["y"],
                "comment": f"Transferir item {i+1}/{max_items}"
            })
            actions.append({"type": "wait", "duration": 0.15})

        # Passo 5: Aguardar transfer√™ncias completarem
        actions.append({
            "type": "wait",
            "duration": 1.0,
            "comment": "Aguardar transfer√™ncias completarem"
        })

        # Passo 6: Fechar ba√∫
        actions.extend(self._build_chest_close())

        logger.info(f"‚úÖ Sequ√™ncia de cleaning constru√≠da: {len(actions)} a√ß√µes")
        return actions

    def build_maintenance_sequence(
        self,
        rod_status: Dict[int, str],
        available_items: Dict[str, List[Dict]]
    ) -> List[Dict]:
        """
        Construir sequ√™ncia completa de manuten√ß√£o de varas

        Sequ√™ncia:
        1. Parar fishing cycle
        2. Remover vara da m√£o
        3. Abrir ba√∫
        4. Para cada slot que precisa manuten√ß√£o:
           - Se quebrada/vazia: arrastar vara nova
           - Se sem isca: arrastar isca (seguindo prioridade)
        5. Fechar ba√∫
        6. Equipar vara

        Args:
            rod_status: {1: "COM_ISCA", 2: "SEM_ISCA", 3: "QUEBRADA", ...}
            available_items: {
                "rods": [{"x": 1300, "y": 200}, ...],
                "baits": [{"x": 1400, "y": 300, "type": "carneurso"}, ...]
            }

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.info(f"üîß Construindo sequ√™ncia de maintenance")
        logger.info(f"   Status: {rod_status}")
        logger.info(f"   Varas dispon√≠veis: {len(available_items.get('rods', []))}")
        logger.info(f"   Iscas dispon√≠veis: {len(available_items.get('baits', []))}")

        actions = []

        # Passo 1: Parar fishing cycle
        actions.extend(self._build_stop_fishing())

        # Passo 2: Remover vara da m√£o
        current_rod = self.config.get("current_rod", 1)
        actions.append({
            "type": "key_press",
            "key": str(current_rod),
            "comment": f"Remover vara {current_rod} da m√£o"
        })
        actions.append({"type": "wait", "duration": 0.3})

        # Passo 3: Abrir ba√∫
        actions.extend(self._build_chest_open())

        # Passo 4: Aguardar ba√∫ abrir
        actions.append({
            "type": "wait",
            "duration": 1.5,
            "comment": "Aguardar ba√∫ abrir"
        })

        # Passo 5: Loop de manuten√ß√£o para cada slot
        slot_positions = self.config.get("slot_positions", {})
        available_rods = available_items.get("rods", []).copy()
        available_baits = available_items.get("baits", []).copy()

        for slot, status in rod_status.items():
            slot_pos = slot_positions.get(str(slot))
            if not slot_pos:
                logger.warning(f"‚ö†Ô∏è Slot {slot} sem posi√ß√£o configurada")
                continue

            # Se vara quebrada ou slot vazio: substituir vara
            if status in ["QUEBRADA", "VAZIO"]:
                if available_rods:
                    rod_loc = available_rods.pop(0)  # Pegar primeira vara dispon√≠vel
                    actions.append({
                        "type": "drag",
                        "from_x": rod_loc["x"],
                        "from_y": rod_loc["y"],
                        "to_x": slot_pos[0],
                        "to_y": slot_pos[1],
                        "comment": f"Substituir vara no slot {slot}"
                    })
                    actions.append({"type": "wait", "duration": 0.5})
                else:
                    logger.warning(f"‚ö†Ô∏è Sem varas dispon√≠veis para slot {slot}")

            # Se sem isca (ou acabou de substituir): colocar isca
            if status in ["SEM_ISCA", "VAZIO", "QUEBRADA"]:
                best_bait = self._get_best_bait(available_baits)
                if best_bait:
                    available_baits.remove(best_bait)  # Remover da lista
                    actions.append({
                        "type": "drag",
                        "from_x": best_bait["x"],
                        "from_y": best_bait["y"],
                        "to_x": slot_pos[0],
                        "to_y": slot_pos[1],
                        "comment": f"Colocar isca ({best_bait.get('type', 'unknown')}) no slot {slot}"
                    })
                    actions.append({"type": "wait", "duration": 0.5})
                else:
                    logger.warning(f"‚ö†Ô∏è Sem iscas dispon√≠veis para slot {slot}")

        # Passo 6: Fechar ba√∫
        actions.extend(self._build_chest_close())

        # Passo 7: Equipar vara
        target_rod = self.config.get("target_rod", current_rod)
        actions.extend(self._build_equip_rod(target_rod))

        logger.info(f"‚úÖ Sequ√™ncia de maintenance constru√≠da: {len(actions)} a√ß√µes")
        return actions

    def build_rod_switch_sequence(self, target_rod: int) -> List[Dict]:
        """
        Construir sequ√™ncia de troca de vara (modo direto, sem ba√∫)

        Sequ√™ncia:
        1. Segurar bot√£o direito
        2. Pressionar n√∫mero da pr√≥xima vara

        Args:
            target_rod: N√∫mero da vara (1-6)

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.info(f"üé£ Construindo sequ√™ncia de rod switch para vara {target_rod}")

        actions = [
            {
                "type": "mouse_down_relative",
                "button": "right",
                "comment": "Segurar bot√£o direito"
            },
            {
                "type": "wait",
                "duration": 0.5
            },
            {
                "type": "key_press",
                "key": str(target_rod),
                "comment": f"Equipar vara {target_rod}"
            },
            {
                "type": "wait",
                "duration": 0.3
            }
        ]

        logger.info(f"‚úÖ Sequ√™ncia de rod switch constru√≠da: {len(actions)} a√ß√µes")
        return actions

    # ========== M√âTODOS AUXILIARES PRIVADOS ==========

    def _build_chest_open(self) -> List[Dict]:
        """
        Sequ√™ncia de abrir ba√∫ (baseada no v3 que FUNCIONA)

        Sequ√™ncia EXATA do chest_manager.py - execute_standard_macro():
        1. Safety: Soltar ALT preventivamente
        2. Safety: Soltar bot√µes do mouse
        3. Parar a√ß√µes cont√≠nuas (cliques, movimentos A/D)
        4. ALT DOWN (segurar)
        5. Movimento de c√¢mera (dx, dy)
        6. Pressionar E
        7. ALT permanece pressionado!

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        chest_side = self.config.get("chest_side", "left")
        chest_distance = self.config.get("chest_distance", 1200)
        chest_vertical = self.config.get("chest_vertical_offset", 200)

        # Calcular dx, dy baseado no lado do ba√∫
        dx = chest_distance if chest_side == "left" else -chest_distance
        dy = abs(chest_vertical)

        logger.debug(f"   Chest open: side={chest_side}, dx={dx}, dy={dy}")

        return [
            # Safety releases
            {
                "type": "key_up",
                "key": "alt",
                "comment": "Safety: garantir ALT solto"
            },
            {
                "type": "mouse_up",
                "button": "right",
                "comment": "Safety: soltar bot√£o direito"
            },
            {
                "type": "mouse_up",
                "button": "left",
                "comment": "Safety: soltar bot√£o esquerdo"
            },
            {
                "type": "stop_continuous_clicking",
                "comment": "Parar cliques cont√≠nuos"
            },
            {
                "type": "stop_camera_movement",
                "comment": "Parar movimentos A/D"
            },
            {
                "type": "wait",
                "duration": 0.1
            },

            # Sequ√™ncia principal de abertura
            {
                "type": "key_down",
                "key": "alt",
                "comment": "ALT DOWN (inicia sequ√™ncia)"
            },
            {
                "type": "wait",
                "duration": 0.8
            },
            {
                "type": "move_camera",
                "dx": dx,
                "dy": dy,
                "comment": f"Mover c√¢mera para ba√∫ ({chest_side})"
            },
            {
                "type": "wait",
                "duration": 0.3
            },
            {
                "type": "key_press",
                "key": "e",
                "comment": "Pressionar E (abrir ba√∫)"
            },
            {
                "type": "wait",
                "duration": 0.5,
                "comment": "ALT ainda pressionado!"
            }
        ]

    def _build_chest_close(self) -> List[Dict]:
        """
        Sequ√™ncia de fechar ba√∫ (baseada no v3 que FUNCIONA)

        Sequ√™ncia:
        1. Soltar ALT
        2. Aguardar 1 segundo
        3. Pressionar TAB
        4. Force release TAB (via Arduino, se dispon√≠vel)
        5. Aguardar 0.8s

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.debug(f"   Chest close")

        return [
            {
                "type": "key_up",
                "key": "alt",
                "comment": "Soltar ALT"
            },
            {
                "type": "wait",
                "duration": 1.0,
                "comment": "Aguardar antes de fechar"
            },
            {
                "type": "key_press",
                "key": "tab",
                "comment": "Pressionar TAB (fechar)"
            },
            {
                "type": "force_release_key",
                "key": "tab",
                "comment": "Force release TAB (Arduino)"
            },
            {
                "type": "wait",
                "duration": 0.8,
                "comment": "Aguardar ba√∫ fechar"
            }
        ]

    def _build_stop_fishing(self) -> List[Dict]:
        """
        Parar fishing cycle antes de abrir ba√∫

        Para:
        - Cliques cont√≠nuos (fast phase)
        - Movimentos de c√¢mera (A/D)
        - Bot√£o direito (casting)

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.debug(f"   Stop fishing")

        return [
            {
                "type": "stop_continuous_clicking",
                "comment": "Parar cliques cont√≠nuos"
            },
            {
                "type": "stop_camera_movement",
                "comment": "Parar movimentos A/D"
            },
            {
                "type": "mouse_up",
                "button": "right",
                "comment": "Soltar bot√£o direito"
            },
            {
                "type": "mouse_up",
                "button": "left",
                "comment": "Soltar bot√£o esquerdo"
            },
            {
                "type": "wait",
                "duration": 0.6,
                "comment": "Aguardar a√ß√µes pararem"
            }
        ]

    def _build_equip_rod(self, target_rod: int) -> List[Dict]:
        """
        Equipar vara ap√≥s fechar ba√∫ (para maintenance)

        Sequ√™ncia:
        1. Segurar bot√£o direito
        2. Aguardar 0.8s
        3. Pressionar n√∫mero da vara
        4. Aguardar 0.6s

        Args:
            target_rod: N√∫mero da vara (1-6)

        Returns:
            Lista de a√ß√µes at√¥micas
        """
        logger.debug(f"   Equip rod: {target_rod}")

        return [
            {
                "type": "mouse_down_relative",
                "button": "right",
                "comment": "Segurar bot√£o direito"
            },
            {
                "type": "wait",
                "duration": 0.8
            },
            {
                "type": "key_press",
                "key": str(target_rod),
                "comment": f"Equipar vara {target_rod}"
            },
            {
                "type": "wait",
                "duration": 0.6
            }
        ]

    def _get_best_bait(self, available_baits: List[Dict]) -> Optional[Dict]:
        """
        Selecionar melhor isca dispon√≠vel seguindo prioridade

        Prioridade (do melhor para pior):
        1. carneurso (carne de urso)
        2. carnedelobo (carne de lobo)
        3. TROUTT (truta)
        4. grub (larva)
        5. minhoca (worm)

        Args:
            available_baits: Lista de iscas dispon√≠veis
                [{"x": 1400, "y": 300, "type": "carneurso"}, ...]

        Returns:
            Melhor isca dispon√≠vel ou None
        """
        if not available_baits:
            return None

        # Obter prioridade do config (ou usar default)
        bait_priority = self.config.get("bait_priority", {
            "crocodilo": 1,
            "carneurso": 2,
            "carnedelobo": 3,
            "bigcat": 4,
            "TROUTT": 5,
            "grub": 6,
            "minhoca": 7
        })

        # Ordenar iscas por prioridade (menor n√∫mero = melhor)
        def get_priority(bait: Dict) -> int:
            bait_type = bait.get("type", "unknown")
            return bait_priority.get(bait_type, 99)  # 99 = prioridade baixa se n√£o encontrado

        sorted_baits = sorted(available_baits, key=get_priority)
        best_bait = sorted_baits[0]

        logger.debug(f"   Melhor isca: {best_bait.get('type', 'unknown')}")
        return best_bait
